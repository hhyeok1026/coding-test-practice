package officialhome.concepts.e_Functions.builders

/*
    Type-safe builders


    receiver와 함께 함수리터럴과 결합된 빌러로 알려진 함수를 하용 함으로써,
    type-safe를 만드는 것이 가능하다, 코틀린의 정적으로 타입인 빌더로.

    type-safe builder는 코틀린 베이스 domain-specific languages (DSls) 적절한게 만드는것을 한다.
    semi-declarative 방법안에 building complex hierarchical data structures에 대해서,
    빌더의 샘플 사용예는 다음과 같다.

    - 코틀린 코드에서 마크업을 만드는것, HTML or XML

    - web server에 대해서 루트를 구성하는것: Ktor

    다음 코드를 고려하라.

    import com.example.html.* // see declarations below

    fun result() =
        html {
            head {
                title {+"XML encoding with Kotlin"}
            }
            body {
                h1 {+"XML encoding with Kotlin"}
                p  {+"this format can be used as an alternative markup to XML"}

                // an element with attributes and text content
                a(href = "https://kotlinlang.org") {+"Kotlin"}

                // mixed content
                p {
                    +"This is some"
                    b {+"mixed"}
                    +"text. For more see the"
                    a(href = "https://kotlinlang.org") {+"Kotlin"}
                    +"project"
                }
                p {+"some text"}

                // content generated by
                p {
                    for (arg in args)
                        +arg
                }
            }
        }


    이건 완전히 정당한 코틀린 코드이다.
    너는 이 코트를 온라인에서 실행 할 수 있다.




    // ==============
    // How it works
    // ==============

    코틀린에서 type-safe builder를 구현이 필요하다고 가정하자
    우선,
    너가 빌드하기 원하는 모델을 정의하라.
    이경우에, 너는 HTML태그 모델을 하는게 필요하다.
    그것은 class의 bunch로 쉽게 한다.
    예를 들어,
    HTML 클래스는 <html>태그로 정의되는 children으로 묘사된다, <head>, <body>같은.
    ( 그것의 선언은 더 아래를 보라 )

    이제 이 코드에서 다음과 같이 말할 수 있는것을 생각해보자.

    html {
        ...
    }

    html은 실제로 함수호출이다, argument 로서 람다표현식을 가지는.
    이 함수는 다음과 같이 정의된다.

    fun html(init: HTML.() -> Unit): HTML {
        val html = HTML()
        html.init()
        return html
    }

    이 함수는 init이라는 하나의 파라미터를 가진다, 그것은 그 스스로 함수이다.
    함수의 타입은 HTML.() -> Unit이다, 리시버가 있는 함수타입이다.
    이것은 의미한다, 함수에서 HTML(리시버) 타입의 인스턴스가 전달되야한다는게.
    그리고 너는 함수 내부에서 그 인스턴스의 멤버를 호출 할 수 있다.

    그 리시버는 this 키워드를 통해 접근 될 수 있다.

    html {
        this.head { ... }
        this.body { ... }
    }

    (head and body는 HTML의 멤버함수이다.)

    이제, this는 생략된다, 대게 그리고 너는 이미 빌더와 같은 것을 볼 수 있다.

    html {
        head { ... }
        body { ... }
    }

    그래서, 이 호출은 무엇인가?
    위에 정의된 html 함수의 바디를 보라.
    그것은 HTML의 새 인스턴스를 만든다,
    그것은 함수가 호출하면서 초기화 된다, argument가 전달된 (이 예제에서, head와 body가 불려진다.)
    그리고 그것은 이 인스턴스를 리턴한다.
    이것은 빌더가 해야하는것이다.

    html안에서 head and body함수는
    html과 유사하게 정의된다.
    다른것은, 그것들은 enclosing HTML 인스턴스의 children collection로 빌드인스턴를 추가한다.

    fun head(init: Head.() -> Unit): Head {
        val head = Head()
        head.init()
        children.add(head)
        return head
    }

    fun body(init: Body.() -> Unit): Body {
        val body = Body()
        body.init()
        children.add(body)
        return body
    }

    실제로 이 두 함수는 같은것이다, 그래서 너는 제너릭 버전을 가진다, initTag:

    protected fun <T: Element> initTag(tag: T, init: T.() -> Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }

    이제, 너의 함수는 매우 간단하다.

    fun head(init: Head.() -> Unit) = initTag(Head(), init)
    fun body(init: Body.() -> Unit) = initTag(Body(), init)

    그리고 너는 그것들을 만들기 위해서 <head>와 <body> 태그를 쓸 수 있다.

    여기서 다른 논의해봐야할 것은, 어떻게 너가 tag바디를 더하냐이다.
    위의 예에서 너는 다음과 같이 말한다.

    html {
        head {
            title {+"XML encoding with Kotlin"}
        }
    }

    그래서 기본적으로, 너는 태그 바디 내부에 string을 넣을 수 있다,
    그러나 그것 앞에 작은 +rk dlTek.
    그래서 그것은 prefix unaryPlus()를 호출한다.
    그 연산자는 사실 확장함수 unaryPlus()에 의해 정의된다, TagWithText 추상 클래스의 멤버인 (Title의 부모)

    operator fun String.unaryPlus() {
        children.add(TextElement(this))
    }

    그래서 여기있는 +는 TextElement의 인스턴스로 String을 랩핑한다.
    그리고 children 컬렉션으로 그것을 더한다, 하기위해서, 그것이 태그 트리의 적절한 부분이 되기 위해

    이 모든것은 패키지 com.example.html에 정의되어 있다, 그 빌더 예제의 상위에 임포트된.

    마지막 섹션에서 너는 읽을 수 있다, 이 패키지의 전체 정의를 통해




    // ===========================
    // Scope control: @DslMarker
    // ===========================

    DSLs(도메인 구체화 랭귀지)를 사용할때,
    한가지 문제점이 있다, 컨텍스트 안에 너무 많은 함수가 불려질 수 있다.
    너는 암시적 리시버가 가능한 모든 매서드를 호출 할 수 있다, 람다내부에, 그리고
    그리므로 일관되지 않은 결과를 얻을 수 있다,
    다른 head 내부에 head 태그같은.

    html {
        head {
            head { } // should be forbidden
        }
    }

    이 예에서, 가장 근처의 암시적 리시버 this@head의 멤버들만 사용가능해야한다.
    head()는 outer receiver this@html의 멤버이다,
    그래서 그것은 그것을 호출하는 것을 허락되지 않는다.

    이 문제를 다루기 위해서, receiver scope를 조절하는 특별한 메커니즘이 있다.

    컴파일러가 스코프 조절을 시작하기 위해서, 너는 같은 마커 어노테이션해야한다, DSL안에서 사용된 모든 리시버의 타입을
    예를 들어, HTML빌더에 대해서 너는 @HTMLTagMarker 어노테이션을 선언한다.

    @DslMarker
    annotation class HtmlTagMarker

    그 어노테이션 클래스는 DSL marker로 불려진다, 만약 @DslMarker로 어노테이션 되어 있다면.

    DSL내에서 모들 테스클래스는 같은 수퍼클래스 Tag를 확장한다.
    그것은 충분하다, 어노테이트 하기위해서 오직 @HtmlTagMarker로 그 수퍼클래스를
    그리고 이후에 코틀린 컴파일러가 어노테이드로 상속된 클래스를 모두 처리할것이다.

    @HtmlTagMarker
    abstract class Tag(val name: String) { ... }

    너는 HTML 이나 Head 클래스는 @HTMLTagMarker로 어노테이트 하면 안된다,
    그들의 수퍼클래스는 이미 어노테이트 되었기 때문이다.

    class HTML() : Tag("html") { ... } class Head() : Tag("head") { ... }

    이 어노테이트를 추가한 이후에, 코틀린 컴파일러는 안다,
    암시적 리시버가 같은 DSL의 부분이라는것을, 그리고 가장 근접한 리시버의 멤버를 호출한다.

    html {
        head {
            head { } // error: a member of outer receiver
        }
    }

    주의해라, 그것은 여전히 outer receiver의 멤버를 호출하는게 가능하다,
    그러나 너는 이 리시버를 명시적으로 구체화해야한다.

    html {
        head {
            this@html.head { } // possible
        }
    }




    // ================================================
    // Full definition of the com.example.html package
    // ================================================

    이것은 어떻게 패키지 com.example.html이 정의 되어 있는지 (오직 위의 예에서의 사용된 elements)
    이것은 HTML tree이다.
    그것은 많은 사용을 만든다, 확장함수와 리시버가 있는 람다의.

    package com.example.html

    interface Element {
        fun render(builder: StringBuilder, indent: String)
    }

    class TextElement(val text: String) : Element {
        override fun render(builder: StringBuilder, indent: String) {
            builder.append("$indent$text\n")
        }
    }

    @DslMarker
    annotation class HtmlTagMarker

    @HtmlTagMarker
    abstract class Tag(val name: String) : Element {
        val children = arrayListOf<Element>()
        val attributes = hashMapOf<String, String>()

        protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {
            tag.init()
            children.add(tag)
            return tag
        }

        override fun render(builder: StringBuilder, indent: String) {
            builder.append("$indent<$name${renderAttributes()}>\n")
            for (c in children) {
                c.render(builder, indent + "  ")
            }
            builder.append("$indent</$name>\n")
        }

        private fun renderAttributes(): String {
            val builder = StringBuilder()
            for ((attr, value) in attributes) {
                builder.append(" $attr=\"$value\"")
            }
            return builder.toString()
        }

        override fun toString(): String {
            val builder = StringBuilder()
            render(builder, "")
            return builder.toString()
        }
    }

    abstract class TagWithText(name: String) : Tag(name) {
        operator fun String.unaryPlus() {
            children.add(TextElement(this))
        }
    }

    class HTML : TagWithText("html") {
        fun head(init: Head.() -> Unit) = initTag(Head(), init)

        fun body(init: Body.() -> Unit) = initTag(Body(), init)
    }

    class Head : TagWithText("head") {
        fun title(init: Title.() -> Unit) = initTag(Title(), init)
    }

    class Title : TagWithText("title")

    abstract class BodyTag(name: String) : TagWithText(name) {
        fun b(init: B.() -> Unit) = initTag(B(), init)
        fun p(init: P.() -> Unit) = initTag(P(), init)
        fun h1(init: H1.() -> Unit) = initTag(H1(), init)
        fun a(href: String, init: A.() -> Unit) {
            val a = initTag(A(), init)
            a.href = href
        }
    }

    class Body : BodyTag("body")
    class B : BodyTag("b")
    class P : BodyTag("p")
    class H1 : BodyTag("h1")

    class A : BodyTag("a") {
        var href: String
            get() = attributes["href"]!!
            set(value) {
                attributes["href"] = value
            }
    }

    fun html(init: HTML.() -> Unit): HTML {
        val html = HTML()
        html.init()
        return html
    }
*/

































