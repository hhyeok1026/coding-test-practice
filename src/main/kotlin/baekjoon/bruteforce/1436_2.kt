package baekjoon.bruteforce

/*
종말의수 666

문제를 보고,
입력예제4, 5를 봤을때 문제 자체가 이해가 안된다.

나만 안되는게 아니었다.
질문게시판에 누군가의 첫 질문이 문제 이해가 안된다는 질문이었다.

숫자가 작은 수로 666을 넣어서 만들어야하는 369같은 게임이라 해야하나?

// 아이디어2
규칙을 찾아서 하는게 아니라,
무작정 숫자 1씩 증가시키면서
문자열처리로 중간에 666이 들어가 있으면 배열에 넣어서 만들면 되겠네?

'666' -> 끝에 6이 있을때, 앞자리가 6이 아니면 문제가 생김. -> 이 경우 prefix를 붙임.
1666
2666
3666
4666
5666
6660 -> 앞이 6이되면, 뒷자리를 더해도 상관이 없다.
6661
6662
6663
6664
6665
'6666' -> 끝이 6인데, 앞이 6이라 문제가 없다.
6667
6668
6669 -> 끝이 9에 있을때 올림이 생겨서 문제가 생길거다.

16660
66690
66600
규칙을 찾으려했다가 위의 3가지를 생각했는데,
문제풀어보니 7666이었다.. ㅋㅋ!


지금은 666 3개라서 그렇다쳐도, 6666이 4개로 있으면 머리가 더 아프겠는데?

일단 10시까지 풀어보자.

처음에 접근했던게
뭔가 규칙이 필요했던거라서
cpu부하보다 내 머리 부하가 커서 풀수가 없었다.

아이디어2로 풀어야겠다.

 */

fun main(args: Array<String>) {
    val br = System.`in`.bufferedReader()
    val n = br.readLine().toInt()

    val first666 = 666
    val listOf666 = mutableListOf<Int>()
    listOf666.add(first666)

    var count = first666
    while (listOf666.size < n) {
        count += 1
        if ( (count).toString().contains("666") ) {
            listOf666.add(count)
            //println(count)
        }
    }

    println(listOf666[n - 1])
}